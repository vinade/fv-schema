!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).FVSchema={})}(this,function(e){"use strict";const t={STRING:"This value must be a string.",NUMBER:"This value must be a number.",INTEGER:"This value must be an integer.",OBJECT:"This value must be an object.",ARRAY:"This value must be an array.",EMAIL:"This value must be a valid email address.",REQUIRED:"This value is required.",MIN:"This value is below the allowed minimum.",MAX:"This value exceeds the allowed maximum.",EQUAL:"This value does not match the expected value.",ONE_OF:"This value is not one of the allowed values.",MATCHES:"This value does not match the required pattern.",CUSTOM:"This value is invalid."};class r{constructor(e){const t=typeof e;if("string"!==t&&"function"!==t)throw new Error("Dynamic error messages constructos expects string or function as parameter.");this.fn=e}compute(e,t){return"string"==typeof this.fn?this.fn:this.fn(e,t)}}function a(e,t){if(e instanceof r&&(e=e.compute(t,t._params||[])),"string"!=typeof e)return"";return e.replace(/\{([^}]+)\}/g,(e,r)=>{if("value"===r)return String(t.value??"");if("name"===r)return String(t.name??"");if(/^\d+$/.test(r)){const e=Number(r);return t._params?.[e]??""}return""})}class n extends Error{constructor(e,t){super(e),this.name="DataTypeError",this.report=t}}class i extends Error{constructor(e){super(e),this.name="BadSchemaError"}}let s=!1;try{s="test"===process.env.NODE_ENV}catch(e){}const o=Symbol("SC_RULE_INSTANCE"),l=function(e){this.path=e.split(".")},u={EMAIL:/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/},c=new Set(["string","number","integer","object","array","email"]),h=new Set([]),f=(()=>{const e={},t={newInstance:function(){return{chain:[],_isNullable:null,_isRequired:null,_shape:null,_of:null,...p}},cloneInstance:function(e){return{chain:[...e.chain],_isRequired:e._isRequired,_isNullable:e._isNullable,_shape:e._shape,_of:e._of,...p}}};return e.newSRInstance=e=>{if(!e)throw new Error("Critic error. SR reference is lost.");if(!e[o])throw new Error("Critic error. SR reference is invalid.");return e===p?t.newInstance():t.cloneInstance(e)},e.registerRule=(e,t,r)=>{if("function"==typeof t&&(t=p.custom(t)),!m.isSchemaRuleInstance(t))throw new i(`SRuleFactory.registerRule() expects an SR chain or a function. Received ${typeof t} ${t}`);const a=new w(t);h.add(e),p[e]=d.valFactor(async(...e)=>{let t=!0;const[r,i]=e,s=e[e.length-1];try{await a.validate(r,!1,e,s?.root)}catch(e){if(!(e instanceof n))throw e;t=e}return t},r,void 0,!0)},e})(),d=(()=>{const e={},t={getValueFromPath:(e,t)=>{let r=t;for(const t of e){if(null==r||"object"!=typeof r)return;r=r[t]}return r}};return e.resolveParams=(r,a)=>{let n=r;return r instanceof l?t.getValueFromPath(r.path,a):(m.isArray(r)?(n=[...r],n.forEach((t,r)=>{n[r]=e.resolveParams(n[r],a)})):m.isPlainObject(r)&&(n={...r},Object.keys(n).forEach(t=>{n[t]=e.resolveParams(n[t],a)})),n)},t.filterArgs=e=>e=(e=e||[]).slice(1,-2),e.valFactor=(r,a,n,o)=>function(...l){const u=f.newSRInstance(this),c={fn:async a=>{const{value:n,data:i,bypass:s,root:u,args:c}=a;if(s)return!0;const h=[...e.resolveParams(l,u??i),...t.filterArgs(c)];a._params=h;const f=[n,...h,i];return o&&f.push(a),r(...f)},errorMessage:a};if(s&&(c.val=r),n){if(u[n]=c,u._isRequired&&u._isNullable)throw new i("A field cannot be nullable and required at the same time.");return u}if(u._shape)throw new i("Rules cannot be applied to shaped objects");return u.chain.push(c),u},e})(),m=(()=>{const e={isPlainObject:e=>"object"==typeof e&&null!==e&&"[object Object]"===Object.prototype.toString.call(e),isEqual:(e,t)=>e===t,isString:e=>"string"==typeof e,isNumber:e=>"number"==typeof e&&!isNaN(e),isInteger:t=>!!e.isNumber(t)&&(!!isFinite(t)&&Math.floor(t)==t),isNull:e=>null===e||(void 0===e||""===e),isObject:t=>!e.isNull(t)&&(!Array.isArray(t)&&"object"==typeof t),isArray:e=>Array.isArray(e),isEmpty:t=>!!e.isNull(t)||(Array.isArray(t)?!t.length:"object"==typeof t&&!Object.keys(t).length),isEmail:t=>!!e.isString(t)&&u.EMAIL.test(t),isValidBy:(t,r)=>{if(!(r instanceof RegExp))throw new i(`A regular expression was expected, but ${r} received instead.`);return!!e.isString(t)&&r.test(t)},isGreaterThanOrEqual:(t,r)=>{if(!e.isNumber(r))throw new i(`A number was expected, but ${r} received instead.`);return!!e.isNumber(t)&&t>=r},isLowerThanOrEqual:(t,r)=>{if(!e.isNumber(r))throw new i(`A number was expected, but ${r} received instead.`);return!!e.isNumber(t)&&t<=r},isOneOf:(t,r)=>{if(!e.isArray(r))throw new i(`An array was expected, but ${r} received instead.`);if(e.isEmpty(r))throw new i(`This rule will always fail. ${t} cannot be one of the elements of an empty array`);return-1!==r.indexOf(t)},isSchemaRuleInstance:e=>Boolean(e&&e[o]),isValidRule:e=>!!c.has(e)||h.has(e)};return e})(),p=(()=>{const e={},a=d.valFactor;return e.noop=a(()=>!0),e.equal=a(m.isEqual,t.EQUAL),e.string=a(m.isString,t.STRING),e.number=a(m.isNumber,t.NUMBER),e.integer=a(m.isInteger,t.INTEGER),e.object=a(m.isObject,t.OBJECT),e.array=a(m.isArray,t.ARRAY),e.email=a(m.isEmail,t.EMAIL),e.required=a(e=>!m.isNull(e),t.REQUIRED,"_isRequired"),e.nullable=a((e,t,r)=>(r.bypass=m.isNull(e),!0),"","_isNullable",!0),e.matches=a(m.isValidBy,t.MATCHES),e.min=a((e,t)=>m.isString(e)?m.isGreaterThanOrEqual(e.length,t):m.isGreaterThanOrEqual(e,t),t.MIN),e.max=a((e,t)=>m.isString(e)?m.isLowerThanOrEqual(e.length,t):m.isLowerThanOrEqual(e,t),t.MAX),e.oneOf=a(m.isOneOf,t.ONE_OF),e.custom=a((e,t,...r)=>t(...[e,...r]),t.CUSTOM),e.error=function(e){const t=f.newSRInstance(this);if(!t.chain.length)throw new i(".error() must follow a rule");return e instanceof r||(e=new r(e)),t.chain[t.chain.length-1].errorMessage=e,t},e.transform=a((e,t,r,a)=>(a.value=t(e,r),!0),void 0,void 0,!0),e.shape=function(e){const t=f.newSRInstance(this);if(t._shape=new w(e),t.chain.length)throw new i("Rules cannot be applied to shaped objects");return t},e.ref=function(e){if("string"!=typeof e)throw new i("Ref path must be a string.");return new l(e)},e.of=function(e){const t=f.newSRInstance(this);if(!e||!(e[o]||e instanceof w))throw new i(".of() expects a SC chain or Schema instance");return t._of=e instanceof w?e:new w(e),t},e.register=(e,t,r)=>{if(c.has(e))throw new i("You should not override a native method. If you want to do this, use the .override() method.");f.registerRule(e,t,r)},e.override=f.registerRule,e.extend=e=>{if(!m.isPlainObject(e))throw new i(".extend() expects a plain object (key:value), with SR chains");const t=Object.keys(e);t.forEach(t=>{if(c.has(t))throw new i("You should not override a native method. If you want to do this, use the .override() method.");if(!e[t][o])throw new i("The values of .extend() param must be SR chains. Like SR.string().required()")}),t.forEach(t=>{f.registerRule(t,e[t])})},e[o]=!0,e})(),w=function(e){const r={isRawChain:!1,executeRules:async function(e,t,r){let i;for(const{fn:s,errorMessage:o}of t){const t=await s(e);let l=!!t;if(e._params=d.resolveParams(e._params,e.root),t instanceof n){const r=a(o,e);i=r?[r,t.report]:t.report;continue}if(!l){i=i||[];const t=a(o,e);if(i.push(t),r)break}}return i},createContext:(e,t,r,a,n)=>{const i=n??r;return{name:e,value:t,data:i,args:a,root:i}},validateField:async(e,t,a)=>{const n=await r.validatePreChain(e,t,a);if(n)return n;if(t.bypass)return;const i=await r.validateShape(e,t,a);if(i)return i;const s=await r.validateArrayItems(e,t,a);return s||(e.chain?.length?await r.executeRules(t,e.chain,a):void 0)},validatePreChain:async(e,t,a)=>{const n=[e._isRequired,e._isNullable].filter(Boolean);return r.executeRules(t,n,a)},validateShape:async(e,r,a)=>{if(e._shape){if(!m.isObject(r.value))return[t.OBJECT];try{await e._shape.validate(r.value,a,void 0,r.root)}catch(e){if(e instanceof n)return e.report;throw e}}},validateArrayItems:async(e,t,r)=>{if(!e._of)return;if(!m.isArray(t.value))return[DEFAULT_ARRAY_FAIL_MESSAGE];const a=[];for(let i=0;i<t.value.length;i++)try{await e._of.validate(t.value[i],r,void 0,t.root),a.push(void 0)}catch(e){if(!(e instanceof n))throw e;if(a.push(e.report),r)break}return a.some(Boolean)?a:void 0}};if(this.validate=async(e,t=!1,a=void 0,i=void 0)=>{r.isRawChain&&(e={value:e});const s=Object.keys(r.schemaObj);let o={},l=!0;for(const n of s){const s=r.schemaObj[n],u=e[n],c=r.createContext(n,u,e,a,i),h=await r.validateField(s,c,t);void 0!==h&&(o[n]=h,l=!1)}if(!l)throw new n("Data validation failed.",r.isRawChain?o.value:o)},m.isSchemaRuleInstance(e))r.schemaObj={value:e},r.isRawChain=!0;else{if(!m.isPlainObject(e))throw new i("Invalid schema description on Schema constructor.");r.schemaObj=e}},v=function(e){const t=this,r={};if(!(e instanceof HTMLFormElement))throw new Error("Invalid form reference");r.form=e,t.readForm=function(){const e=r.form,a=Array.from(e.elements),n={},i={};return t.elements=a,a.forEach(e=>{if(!e.name||e.disabled)return;const{tagName:t,name:r,value:a,multiple:s,options:o}=e,l=t.toUpperCase();if(n.hasOwnProperty(r)||(n[r]=null),"INPUT"===l){const{type:t,checked:s}=e;switch(t){case"radio":s&&(n[r]=a);break;case"checkbox":i[r]||(i[r]={value:[],counter:0}),s&&i[r].value.push(a),i[r].counter+=1;break;default:n[r]=a}}else n[r]="SELECT"===l&&s?Array.from(o).filter(e=>e.selected).map(e=>e.value):a}),Object.entries(i).forEach(([e,t])=>{1===t.counter?n[e]=void 0!==t.value[0]?t.value[0]:null:n[e]=t.value}),n},r.readFlagAttribute=(e,t)=>{if(!e.hasAttribute(t))return!1;const r=e.getAttribute(t);return!/false/i.test(`${r}`)},t.buildSchema=function(){const e={};return r.elementMap={},void 0===t.elements&&t.readForm(),t.elements.forEach(t=>{const a=t.getAttribute("name"),n=t.getAttribute("data-type"),s=r.readFlagAttribute(t,"required"),o=t.getAttribute("data-ref"),l=r.readFlagAttribute(t,"nullable");if(!a)return;let u=p;if(s&&(u=u.required()),l&&(u=u.nullable()),n){if(!m.isValidRule(n))throw new i(`Unknown data-type: ${n}`);u=o?u[n](p.ref(o)):u[n]()}else o&&(u=u.equal(p.ref(o)));u===p&&(u=u.noop()),e[a]=u,r.elementMap[a]=t}),t.schema=new w(e),t.schemaDescription=e,t.schema},t.validate=async function(e=!1){const a=t.readForm();t.schema||t.buildSchema();try{return await t.schema.validate(a,e),{valid:!0,errors:null}}catch(e){if(!(e instanceof n))throw e;const t={};return Object.entries(e.report).forEach(([e,a])=>{a&&(t[e]={element:r.elementMap[e],messages:a})}),{valid:!1,errors:t}}}};e.BadSchemaError=i,e.DataTypeError=n,e.DynamicMessage=r,e.ErrorMessages=t,e.FV=v,e.SR=p,e.Schema=w,e.formatMessage=a});
